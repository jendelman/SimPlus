---
title: "SimPlus Vignette"
author: "Jeff Endelman"
date: "2024-06-23"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE,message=FALSE,warning=FALSE,comment="##",
                      dpi=150)
opts_knit$set(root.dir="~/Software/SimPlus/vignettes/")
```

SimPlus was created for testing [COMA](https://github.com/jendelman/COMA) with [AlphaSimR](https://cran.r-project.org/web/packages/AlphaSimR/index.html). COMA provides functions for optimum contribution selection (OCS) and optimum mate allocation (OMA). For OCS, the objective is to maximize the average GEBV of the parents, weighted by their contributions. For OMA, the objective is to maximize the average GPMP (genomic prediction of mate performance), weighted by the mate allocations. 

The following code creates a founder population in mutation-drift equilibrium and sets the variance parameters for a trait with additive and dominance effects. 

```{r}
founders <- runMacs2(nInd=500,nChr=10,segSites=NULL,Ne=100,
                     mutRate=1e-8, ploidy=2,
                     histGen=NULL,histNe=NULL,genLen=1)
SP <- SimParam$new(founders)
SP$setTrackRec(TRUE)
SP$addTraitADG(nQtlPerChr = 100, mean = 0, var = 1, varDD = 0.5, 
               meanDD = 0.5, useVarA = FALSE)
SP$setVarE(varE=2)
pop <- newPop(founders, simParam=SP)
```

The following code runs 20 generations of mass selection at 1% inbreeding, using phenotypes for genetic merit. The population is saved after 5 generations to compare the response with genomic selection. 

```{r}
gp <- genParam(pop, simParam = SP)
total.gen <- 20
results <- data.frame(gen=1:total.gen, mu=numeric(total.gen), 
                      genicVar=numeric(total.gen), 
                      F.coeff=numeric(total.gen), 
                      n.parent=numeric(total.gen), 
                      n.mate=numeric(total.gen),
                      accuracy=numeric(total.gen))  
results$mu[1] <- as.numeric(gp$mu)
results$genicVar[1] <- as.numeric(gp$genicVarG) 

p.ref <- update_TP(pop, SP, geno.file="geno.csv.gz", 
                   pheno.file="pheno.csv", ped.file="ped.csv", 
                   gen.TP=0)
update_K(pop, SP, K.method="A", K.file="kinship.csv", ped.file="ped.csv")

for (gen in 1:total.gen) {
  print(sub("X",gen,"Generation X"))
  ans1 <- sim_OCS(pop, SP, n.progeny=500, dF=0.01, solver="MOSEK",
                  COMA.file="pheno.csv", K.file="kinship.csv")
  
  #optional, measure accuracy
  acc <- sim_accuracy(pop, SP, COMA.file="pheno.csv")
  results$accuracy[gen] <- acc$ocs
  
  ans2 <- sim_mate(pop, SP, matings=ans1$om, total.progeny=500, min.progeny=5)
  results$n.parent[gen] <- ans2$n.parent
  results$n.mate[gen] <- nrow(ans2$matings)
  
  pop <- setPheno(ans2$progeny,simParam = SP) #AlphaSimR function
  gp <- genParam(pop, simParam = SP)
  results$mu[gen] <- as.numeric(gp$mu)
  results$genicVar[gen] <- as.numeric(gp$genicVarG) 
  
  update_TP(pop, SP, geno.file="geno.csv.gz", pheno.file="pheno.csv", 
            ped.file="ped.csv", gen.TP=3)
  results$F.coeff[gen] <- update_K(pop, SP, K.method="A", K.file="kinship.csv", 
                               ped.file="ped.csv")
  if (gen==5)
    sim_save("gen5.rda",pop,SP,"geno.csv.gz","pheno.csv","ped.csv",p.ref=p.ref)
}

all.results <- data.frame(results,sim="OCS-A-Pheno")
```

Even though there is no genomic selection in the above simulation, the function `update_TP` is still required to update the phenotype and pedigree files for OCS. The argument `gen.TP` controls the number of generations in the TP (including the candidates, which are selected after phenotyping). It is set at 3 to anticipate the simulation below, ensuring the full TP is available at the onset of GS in generation 5.

To simulate GS requires another function, `sim_StageWise`, to predict the marker effects using the [StageWise](https://github.com/jendelman/StageWise) package. The file with the predicted marker effects (COMA.file) is now used as input for `sim_OCS` instead of the phenotype file.

```{r}
gen5 <- sim_load("gen5.rda","geno.csv.gz","pheno.csv","ped.csv")
pop <- gen5$pop
SP <- gen5$SP

update_K(pop, SP, K.method="A", K.file="kinship.csv", ped.file="ped.csv")

for (gen in 6:total.gen) {
  print(sub("X",gen,"Generation X"))
  ans0 <- sim_StageWise("geno.csv.gz","pheno.csv",ploidy=2,
                        COMA.file="COMA.csv", gen.TP=3)
  
  ans1 <- sim_OCS(pop, SP, n.progeny=500, dF=0.01, solver="MOSEK",
                  COMA.file="COMA.csv", K.file="kinship.csv")
  
  acc <- sim_accuracy(pop, SP, COMA.file="COMA.csv", K.file="kinship.csv")
  results$accuracy[gen] <- acc$ocs
  
  ans2 <- sim_mate(pop, SP, matings=ans1$om, total.progeny=500, min.progeny=5)
  results$n.parent[gen] <- ans2$n.parent
  results$n.mate[gen] <- nrow(ans2$matings)
  
  pop <- setPheno(ans2$progeny,simParam = SP) 
  gp <- genParam(pop, simParam = SP)
  results$mu[gen] <- as.numeric(gp$mu)
  results$genicVar[gen] <- as.numeric(gp$genicVarG) 
  
  update_TP(pop, SP, geno.file="geno.csv.gz", pheno.file="pheno.csv",
            ped.file="ped.csv", gen.TP=3)
  results$F.coeff[gen] <- update_K(pop, SP, K.method="A", K.file="kinship.csv", 
                               ped.file="ped.csv")
}

results.all <- rbind(results, data.frame(results, sim="OCS-A-GEBV"))
```

Instead of pedigree kinship, genomic IBD (G.IBD) kinship can be used to control inbreeding. To reduce computational time, not all segregating sites are needed for this calculation. The parameter "ibd.loci" in the function `update_K` controls how many loci per chromosome to use. The default is 100, and since the chromosomes are 100 cM, this implies 1 marker per cM. 

```{r}
gen5 <- sim_load("gen5.rda","geno.csv.gz","pheno.csv","ped.csv")
pop <- gen5$pop
SP <- gen5$SP

update_K(pop, SP, K.method="G.IBD", K.file="kinship.csv", 
         ped.file="ped.csv", ibd.loci=100, n.core=2)

for (gen in 6:total.gen) {
  print(sub("X",gen,"Generation X"))
  ans0 <- sim_StageWise("geno.csv.gz","pheno.csv",ploidy=2,
                        COMA.file="COMA.csv", gen.TP=3)
  
  ans1 <- sim_OCS(pop, SP, n.progeny=500, dF=0.01, solver="MOSEK",
                  COMA.file="COMA.csv", K.file="kinship.csv")
  
  acc <- sim_accuracy(pop, SP, COMA.file="COMA.csv", K.file="kinship.csv")
  results$accuracy[gen] <- acc$ocs
  
  ans2 <- sim_mate(pop, SP, matings=ans1$om, total.progeny=500, min.progeny=5)
  results$n.parent[gen] <- ans2$n.parent
  results$n.mate[gen] <- nrow(ans2$matings)
  
  pop <- setPheno(ans2$progeny,simParam = SP) 
  gp <- genParam(pop, simParam = SP)
  results$mu[gen] <- as.numeric(gp$mu)
  results$genicVar[gen] <- as.numeric(gp$genicVarG) 
  
  update_TP(pop, SP, geno.file="geno.csv.gz", pheno.file="pheno.csv",
            ped.file="ped.csv", gen.TP=3)
  results$F.coeff[gen] <- update_K(pop, SP, K.method="G.IBD", 
                                   K.file="kinship.csv", ped.file="ped.csv",
                                   ibd.loci=100, n.core=2)
}

results.all <- rbind(results, data.frame(results, sim="OCS-G.IBD-GEBV"))
```

A genomic kinship matrix based on VanRaden (2008) Method 1 can also be tested for inbreeding control, using the founder allele frequencies (p.ref) as the base population.

```{r}
gen5 <- sim_load("gen5.rda","geno.csv.gz","pheno.csv","ped.csv")
pop <- gen5$pop
SP <- gen5$SP
p.ref <- gen5$p.ref

update_K(pop, SP, K.method="G.VR", K.file="kinship.csv", 
         ped.file="ped.csv", p.ref=p.ref)

for (gen in 6:total.gen) {
  print(sub("X",gen,"Generation X"))
  ans0 <- sim_StageWise("geno.csv.gz","pheno.csv",ploidy=2,
                        COMA.file="COMA.csv", gen.TP=3)
  
  ans1 <- sim_OCS(pop, SP, n.progeny=500, dF=0.01, solver="MOSEK",
                  COMA.file="COMA.csv", K.file="kinship.csv")
  
  acc <- sim_accuracy(pop, SP, COMA.file="COMA.csv", K.file="kinship.csv")
  results$accuracy[gen] <- acc$ocs
  
  ans2 <- sim_mate(pop, SP, matings=ans1$om, total.progeny=500, min.progeny=5)
  results$n.parent[gen] <- ans2$n.parent
  results$n.mate[gen] <- nrow(ans2$matings)
  
  pop <- setPheno(ans2$progeny,simParam = SP) 
  gp <- genParam(pop, simParam = SP)
  results$mu[gen] <- as.numeric(gp$mu)
  results$genicVar[gen] <- as.numeric(gp$genicVarG) 
  
  update_TP(pop, SP, geno.file="geno.csv.gz", pheno.file="pheno.csv",
            ped.file="ped.csv", gen.TP=3)
  results$F.coeff[gen] <- update_K(pop, SP, K.method="G.VR", 
                                   K.file="kinship.csv", ped.file="ped.csv",
                                   p.ref=p.ref)
}

results.all <- rbind(results, data.frame(results, sim="OCS-G.VR-GEBV"))
```

Simulating OMA follows the same code as above but replaces `sim_OCS` with `sim_OMA`, which has an additional argument `max.parent`. To limit the size of the computational problem for OMA, OCS is first used to reduce the number of candidates to `max.parent`. 

```{r}
gen5 <- sim_load("gen5.rda","geno.csv.gz","pheno.csv","ped.csv")
pop <- gen5$pop
SP <- gen5$SP

update_K(pop, SP, K.method="A", K.file="kinship.csv", 
         ped.file="ped.csv")

for (gen in 6:total.gen) {
  print(sub("X",gen,"Generation X"))
  ans0 <- sim_StageWise("geno.csv.gz","pheno.csv",ploidy=2,
                        COMA.file="COMA.csv", gen.TP=3)
  
  ans1 <- sim_OMA(pop, SP, n.progeny=500, dF=0.01, solver="MOSEK",
                  COMA.file="COMA.csv", K.file="kinship.csv",
                  max.parent=200)
  
  acc <- sim_accuracy(pop, SP, COMA.file="COMA.csv", K.file="kinship.csv")
  results$accuracy[gen] <- acc$oma
  
  ans2 <- sim_mate(pop, SP, matings=ans1$om, total.progeny=500, min.progeny=5)
  results$n.parent[gen] <- ans2$n.parent
  results$n.mate[gen] <- nrow(ans2$matings)
  
  pop <- setPheno(ans2$progeny,simParam = SP) 
  gp <- genParam(pop, simParam = SP)
  results$mu[gen] <- as.numeric(gp$mu)
  results$genicVar[gen] <- as.numeric(gp$genicVarG) 
  
  update_TP(pop, SP, geno.file="geno.csv.gz", pheno.file="pheno.csv",
            ped.file="ped.csv", gen.TP=3)
  results$F.coeff[gen] <- update_K(pop, SP, K.method="A", 
                                   K.file="kinship.csv", ped.file="ped.csv")
}

results.all <- rbind(results, data.frame(results, sim="OMA-A-GPMP"))
```

```{r,echo=F}
write.csv(results.all,"vigette_all.csv")
```

We can now plot the results.

```{r}
library(ggplot2)
library(ggpubr)
p1 <- ggplot(results.all,aes(x=gen,y=mu,colour=method)) + geom_line() +
  ylab("Genetic Gain") + xlab("Generation") + 
  scale_colour_brewer(palette="Set1")
p2 <- ggplot(results.all,aes(x=gen,y=genicVar,colour=method)) + geom_line() +
  ylab("Genic Variance") + xlab("Generation") +
  scale_colour_brewer(palette="Set1")
p3 <- ggplot(results.all,aes(x=gen,y=accuracy,colour=method)) + geom_line() +
  ylab("Selection Accuracy") + xlab("Generation") +
  scale_colour_brewer(palette="Set1")
p4 <- ggplot(results.all,aes(x=gen,y=n.mate,colour=method)) + geom_line() +
  ylab("# Matings") + xlab("Generation") +
  scale_colour_brewer(palette="Set1")

ggarrange(p1,p2,p3,p4,nrow=2,ncol=2,common.legend=T)
```

At 1% inbreeding, OCS-GEBV and OMA-GPMP achieved similar gain by 20 generations, but OMA was more efficient because less genic variance was depleted. The higher accuracy observed for OMA is because GPMP includes the specific combining ability (SCA) of each mating, while OCS only includes GCA. The number of matings required by OMA was much lower than OCS, which was at the imposed limit of 100.